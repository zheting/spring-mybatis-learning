<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- namespace 是接口全类名 -->
<mapper namespace="cn.java.money.mapper.EmployeeMapper">

    <!-- 因为settings中配置 mapUnderscoreToCamelCase=true (默认是false)， 因此last_name 能够映射到 lastName-->
    <!-- 因为配置typeAliases,所以resultType可以写别名 Employee-->
    <!--  databaseId="mysql" 指定该条sql在那个数据库产品执行 -->
    <select id="selectEmp" resultType="emp" databaseId="mysql">
        select * from tbl_employee  where id = #{id}
    </select>

    <!-- id 是方法名   -->
    <select id="getEmployeeById" resultType="emp">
        select id, last_name as lastName, email, gender from tbl_employee  where id = #{id}
    </select>

    <!--
        获取自增主键值：
            useGeneratedKeys="true"使用自增主键获取主键值策略， JDBC Statement.getGeneratedKeys()
            keyProperty="id" 指定对应的主键属性，也就是mybatis获取主键以后，将这个值封装给java bean的那个属性
    -->
    <insert id="addEmployee" useGeneratedKeys="true" keyProperty="id" databaseId="mysql">
        insert into tbl_employee (last_name,email,gender)
        values (#{lastName},#{email},#{gender})
    </insert>

    <!--
        Oracle不支持自增，可以使用序列模拟自增
    -->
    <insert id="addEmployee" useGeneratedKeys="true" keyProperty="id" databaseId="oracle">
        <!--
            keyProperty 查出的主键封装给Java bean 的那个属性
            order="BEFORE" 当前sql在插入sql之前运行
        -->
        <!--<selectKey keyProperty="id" order="BEFORE" resultType="integer">
            select EMPLOYEES_SEQ.nextval from dual
        </selectKey>
        insert into tbl_employee (id,last_name,email,gender)
        values (#{id},#{lastName},#{email},#{gender})
        -->

        <selectKey keyProperty="id" order="AFTER" resultType="integer">
            select EMPLOYEES_SEQ.currval from dual
        </selectKey>

        insert into tbl_employee (id,last_name,email,gender)
            values (EMPLOYEES_SEQ.nextval,#{lastName},#{email},#{gender})
    </insert>


    <update id="updateEmployee" >
        update tbl_employee
            set last_name = #{lastName}, email = #{email}, gender = #{gender}
            where id = #{id}
    </update>

    <delete id="deleteEmployee">
        delete from tbl_employee where id = #{id}
    </delete>

    <select id="getEmployeeByIdAndLastName" resultType="emp">
        <!-- select id, last_name as lastName, email, gender from tbl_employee  where id = #{arg0} and last_name = #{arg1}  -->
        <!-- select id, last_name,  email, gender from tbl_employee  where id = #{param1} and last_name = #{param2} -->
        <!-- @Param 命名参数-->
        select id, last_name,  email, gender from tbl_employee  where id = #{id} and last_name = #{lastName}
    </select>

    <select id="getEmployeeByIdAndLastName2" resultType="emp">
        select id, last_name,  email, gender from tbl_employee  where id = #{id} and last_name = #{lastName}
    </select>

    <select id="getEmployeeByIdAndLastName3" resultType="emp">
        select id, last_name,  email, gender from tbl_employee  where id = #{id} and last_name = #{lastName}
    </select>

    <!--返回多个元素的时候，resultType的值是集合中元素的类型-->
    <select id="getEmployeeByLastName" resultType="emp">
        select id, last_name,  email, gender from tbl_employee  where last_name = #{lastName}
    </select>

    <!--返回值是单条记录 map
        key(就是属性名称) : vlaue
         gender=男,
         last_name=tom,
         id=2,
         email=tom@qq.com
    -->
   <select id="getEmployeeByIdReturnMap" resultType="map">
        select id, last_name,  email, gender from tbl_employee  where id = #{id}
    </select>

    <!--返回多条记录的map:  Map<Integer,Employee>
        resultType是map value的类型
        @MapKey("id") 标明那一列作为key
    -->
    <select id="getEmployeeByLastNameReturnMap" resultType="emp">
        select id, last_name,  email, gender from tbl_employee  where last_name = #{lastName}
    </select>

    <!--
        #{key} 预编译，防止sql注入
        ${key} sql直接拼接，会有安全问题
        大部分情况下使用#{}， 但是当原生JDBC不支持占位符的地方可以使用${}
        比如：按年份分表，表名就是 年份_salary,此时年份就是动态的，但是表名不支持占位符，因此要使用${}
             比如排序的字段和升序降序都不支持占位符 order by ${f_name} ${order}

         #{}中更多的配置
         javaType
         jdbcType
            通常需要在某种特定的条件下被设置
            比如：在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。
                    例如oracle就会报错 JdbcType OTHER 无效的类型； 因为mybatis多所有的null都映射的是原生JDBC的OTHER类型，因此oracle不能正确处理
                      #{email，jdbcType=NULL}  在源码java.sql.JDBCType中可以找OTHER(Types.OTHER),NULL(Types.NULL)
             全局配置settings中有一个配置项 jdbcTypeForNull默认值是OTHER,因此可以在setting中设置jdbcTypeForNull=NULL
         mode(存储过程)
         numericScale
         resultMap
         typeHandler
         jdbcTypeName
         expression
    -->



</mapper>