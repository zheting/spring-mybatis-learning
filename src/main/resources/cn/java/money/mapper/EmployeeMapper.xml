<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- namespace 是接口全类名 -->
<mapper namespace="cn.java.money.mapper.EmployeeMapper">

    <!-- 因为settings中配置 mapUnderscoreToCamelCase=true (默认是false)， 因此last_name 能够映射到 lastName-->
    <!-- 因为配置typeAliases,所以resultType可以写别名 Employee-->
    <!--  databaseId="mysql" 指定该条sql在那个数据库产品执行 -->
    <!-- 该条sql 不是通过接口和mapper关联以后查询的，而是通过 java代码直接关联查询的-->
    <select id="selectEmp" resultType="emp" databaseId="mysql">
        select * from tbl_employee  where id = #{id}
    </select>

    <!-- id 是方法名   -->
    <select id="getEmployeeById" resultType="emp">
        select id, last_name as lastName, email, gender from tbl_employee  where id = #{id}
    </select>

    <!--
        获取自增主键值：
            useGeneratedKeys="true"使用自增主键获取主键值策略， JDBC Statement.getGeneratedKeys()
            keyProperty="id" 指定对应的主键属性，也就是mybatis获取主键以后，将这个值封装给java bean的那个属性
    -->
    <insert id="addEmployee" useGeneratedKeys="true" keyProperty="id" databaseId="mysql">
        insert into tbl_employee (last_name,email,gender)
        values (#{lastName},#{email},#{gender})
    </insert>

    <!--
        Oracle不支持自增，可以使用序列模拟自增
    -->
    <insert id="addEmployee" useGeneratedKeys="true" keyProperty="id" databaseId="oracle">
        <!--
            keyProperty 查出的主键封装给Java bean 的那个属性
            order="BEFORE" 当前sql在插入sql之前运行
        -->
        <!--<selectKey keyProperty="id" order="BEFORE" resultType="integer">
            select EMPLOYEES_SEQ.nextval from dual
        </selectKey>
        insert into tbl_employee (id,last_name,email,gender)
        values (#{id},#{lastName},#{email},#{gender})
        -->

        <selectKey keyProperty="id" order="AFTER" resultType="integer">
            select EMPLOYEES_SEQ.currval from dual
        </selectKey>

        insert into tbl_employee (id,last_name,email,gender)
            values (EMPLOYEES_SEQ.nextval,#{lastName},#{email},#{gender})
    </insert>


    <update id="updateEmployee" >
        update tbl_employee
            set last_name = #{lastName}, email = #{email}, gender = #{gender}
            where id = #{id}
    </update>

    <delete id="deleteEmployee">
        delete from tbl_employee where id = #{id}
    </delete>

    <select id="getEmployeeByIdAndLastName" resultType="emp">
        <!-- select id, last_name as lastName, email, gender from tbl_employee  where id = #{arg0} and last_name = #{arg1}  -->
        <!-- select id, last_name,  email, gender from tbl_employee  where id = #{param1} and last_name = #{param2} -->
        <!-- @Param 命名参数-->
        select id, last_name,  email, gender from tbl_employee  where id = #{id} and last_name = #{lastName}
    </select>

    <select id="getEmployeeByIdAndLastName2" resultType="emp">
        select id, last_name,  email, gender from tbl_employee  where id = #{id} and last_name = #{lastName}
    </select>

    <select id="getEmployeeByIdAndLastName3" resultType="emp">
        select id, last_name,  email, gender from tbl_employee  where id = #{id} and last_name = #{lastName}
    </select>

    <!--返回多个元素的时候，resultType的值是集合中元素的类型-->
    <select id="getEmployeeByLastName" resultType="emp">
        select id, last_name,  email, gender from tbl_employee  where last_name = #{lastName}
    </select>

    <!--返回值是单条记录 map
        key(就是属性名称) : vlaue
         gender=男,
         last_name=tom,
         id=2,
         email=tom@qq.com
    -->
   <select id="getEmployeeByIdReturnMap" resultType="map">
        select id, last_name,  email, gender from tbl_employee  where id = #{id}
    </select>

    <!--返回多条记录的map:  Map<Integer,Employee>
        resultType是map value的类型
        @MapKey("id") 标明那一列作为key
    -->
    <select id="getEmployeeByLastNameReturnMap" resultType="emp">
        select id, last_name,  email, gender from tbl_employee  where last_name = #{lastName}
    </select>

    <!--
        #{key} 预编译，防止sql注入
        ${key} sql直接拼接，会有安全问题
        大部分情况下使用#{}， 但是当原生JDBC不支持占位符的地方可以使用${}
        比如：按年份分表，表名就是 年份_salary,此时年份就是动态的，但是表名不支持占位符，因此要使用${}
             比如排序的字段和升序降序都不支持占位符 order by ${f_name} ${order}

         #{}中更多的配置
         javaType
         jdbcType
            通常需要在某种特定的条件下被设置
            比如：在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。
                    例如oracle就会报错 JdbcType OTHER 无效的类型； 因为mybatis多所有的null都映射的是原生JDBC的OTHER类型，因此oracle不能正确处理
                      #{email，jdbcType=NULL}  在源码java.sql.JDBCType中可以找OTHER(Types.OTHER),NULL(Types.NULL)
             全局配置settings中有一个配置项 jdbcTypeForNull默认值是OTHER,因此可以在setting中设置jdbcTypeForNull=NULL
         mode(存储过程)
         numericScale
         resultMap
         typeHandler
         jdbcTypeName
         expression
    -->

    <!-- 自定义某个JavaBean的封装规则
            type: 自定义规则的Java 类型
            id: 规则的名称，便于被引用
    -->
    <resultMap id="MyEmp" type="cn.java.money.entity.Employee">
            <!--id 标签定义主键，底层会有优化-->
            <id column="id" property="id"/>
            <!-- 定义普通列封装规则 -->
            <result column="last_name" property="lastName"/>
            <!-- 其他不指定的列会自动封装 -->
    </resultMap>

    <!--resultMap 和 resultType 不可以同时使用-->
    <!-- resultMap 比 settings中配置的 mapUnderscoreToCamelCase 优先级高-->
    <select id="getEmployeeByLastName2" resultMap="MyEmp">
        select id, last_name,  email, gender from tbl_employee  where last_name = #{lastName}
    </select>

    <!-- 通过外键 级联属性 -->
    <resultMap id="MyEmp2" type="cn.java.money.entity.Employee2">
        <id column="id" property="id"/>
        <result column="last_name" property="lastName"/>
        <result column="dept_id" property="department.id"/>
        <result column="dept_name" property="department.deptName"/>
    </resultMap>

    <!-- association标签定义级联属性 -->
    <resultMap id="MyEmp3" type="cn.java.money.entity.Employee2">
        <id column="id" property="id"/>
        <result column="last_name" property="lastName"/>
        <association property="department" javaType="cn.java.money.entity.Department">
            <result column="dept_id" property="id"/>
            <result column="dept_name" property="deptName"/>
        </association>
    </resultMap>

    <select id="getEmpAndDept" resultMap="MyEmp3">
        select e.id id, e.last_name, e.email email, e.gender gender, d.id dept_id, d.dept_name dept_Name
        from tbl_employee e, tbl_dept d
        where e.id = d.id and e.id = #{id}
    </select>

    <!--
        使用association进行分步查询
        1.0 根据员工id查询员工信息
        2.0 根据员工信息中的部门id 查询部门信息
        3.0 部门设置给员工

    -->
    <resultMap id="MyEmp4" type="cn.java.money.entity.Employee2">
        <id column="id" property="id"/>
        <result column="last_name" property="lastName"/>
        <!--
            select : 表示要调用哪个方法
            colum: 给方法传参数，这里就是把employee中的dep_id传给getDepartmentById
            property: 把select的查询结果赋值给Employee2的department属性
        -->
        <association property="department" select="cn.java.money.mapper.DepartmentMapper.getDepartmentById" column="dep_id"/>
    </resultMap>
    <select id="getEmpAndDept2" resultMap="MyEmp4">
        select id, last_name, email, gender, dep_id from tbl_employee  where id = #{id}
    </select>

    <!-- 懒加载、延时加载、按需加载
        分步查询的基础上加上如下配置settings就可以开启延时加载：
            <setting name="lazyLoadingEnabled" value="true"/>
            <setting name="aggressiveLazyLoading" value="false"/>
    -->


    <select id="getEmpByDepId" resultType="Employee2">
        select id, last_name, email, gender, dep_id from tbl_employee  where dep_id = #{dep_id}
    </select>

    <!--

       鉴别器：mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为。
       模拟场景： 如果查询出的是女生，就把部门信息查询出来，否则不查询
                如果是男生，把last_name这一列的值赋给email
    -->
    <resultMap id="MyEmp5" type="cn.java.money.entity.Employee2">
        <id column="id" property="id"/>
        <result column="last_name" property="lastName"/>
        <!--
            column： 指定判定的列名
            javaType: 列值对应的类型
        -->
        <discriminator javaType="string" column="gender">
            <case value="男" resultType="Employee2">
                <id column="id" property="id"/>
                <result column="last_name" property="email"/>
            </case>
            <case value="女" resultType="Employee2">
                <association property="department" select="cn.java.money.mapper.DepartmentMapper.getDepartmentById" column="dep_id"/>
            </case>
        </discriminator>
    </resultMap>

    <select id="getEmpAndDept3" resultMap="MyEmp5">
        select id, last_name, email, gender, dep_id from tbl_employee  where id = #{id}
    </select>
</mapper>